/** 
 * 
 */
package fr.utbm.cvrp.solver

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.ParticipantJoined
import io.sarl.core.ParticipantLeft
import io.sarl.core.SpaceCreated
import io.sarl.core.SpaceDestroyed
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Lifecycle
import io.sarl.core.InnerContextAccess
import io.sarl.core.Schedules
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.ConcurrentSkipListSet
import java.util.UUID
import java.util.Collection
import java.util.concurrent.ConcurrentLinkedQueue

/** 
 * @author neil
 * 
 */
agent AllocationAgent {
	uses Logging, DefaultContextInteractions, Lifecycle, InnerContextAccess, Schedules

	// id, x, y of the depot node
	var depot : String
	// Vehicle capacity
	var vehicle_capacity : AtomicInteger = new AtomicInteger()

	// UUID of the task agent
	var taskAgentUUID : UUID
	// Number of vehicle
	var number_vehicle : AtomicInteger

	// The customer actually insert
	var actual_customer_insert : String
	// Number of Vehicle agent that returned a solution
	var number_agent_returned : int = 0
	// Best estimation insertion cost
	var best_insertion_cost : double = Double.MAX_VALUE
	// Best Vehicle agent with the lowest estimation cost
	var best_vehicle_insert : UUID

	// List of uuid to all vehicle agent that must relocates theirs customers
	var vehicle_agents : ConcurrentLinkedQueue<UUID> = new ConcurrentLinkedQueue<UUID>
	// List of customers to relocate
	var customer_relocate : ConcurrentLinkedQueue<String> = new ConcurrentLinkedQueue<String>

	on Initialize {
		// Set the logging name of the agent
		loggingName = "Allocation Agent"
		// Tell on logging that the agent started normally
		info("The agent has started.")

		// Get the customers, depot and capacity
		depot = occurrence.parameters.get(0) as String
		vehicle_capacity = occurrence.parameters.get(1) as AtomicInteger
		// Get it has integer
		var number_vehicle_int = occurrence.parameters.get(2) as Integer
		// Create an atomic int
		number_vehicle = new AtomicInteger(number_vehicle_int)

		// Save the task agent uuid
		taskAgentUUID = occurrence.parameters.get(3) as UUID 
		
		// SARL BUG ?!?
		info(occurrence.source.getID())
		info(taskAgentUUID)

		// Spawn all the vehicle agent
		for (var vehicle_i : int = 1; vehicle_i <= number_vehicle_int; vehicle_i++) {
			// Generate a new UUID
			var vehicleUUID : UUID = UUID.randomUUID()
			// Spawn the VehicleAgent
			spawnInContextWithID(typeof(VehicleAgent), vehicleUUID, innerContext, depot, vehicle_capacity, this.ID)
		}

		// Wait the vehicle agents to spawn
		val task = task("waiting_for_vehicle_agent")
		task.every(100) [
			if (getMemberAgentCount() == number_vehicle.get()) {
				info("New customer is requested.")
				// Ask for a new customer
				emit(new nextCustomerRequest())[it.ID == taskAgentUUID]
				task.cancel
			}
		]
	}

	on nextCustomer {
		info("New customer received.")
		// Get the customer to insert
		actual_customer_insert = occurrence.customer

		// Emit the event in the default space of inner context
		innerContext.defaultSpace.emit(this.ID, new insertCustomerEstimate(actual_customer_insert))
	}

	on finish {
		info("Emitting finish event.")
		// Emit the event in the inner context to the vehicle agents
		innerContext.defaultSpace.emit(this.ID, new finishVehicle())
	}

	on die{
		if (getMemberAgentCount() == 0) {
			info("Killing myself.")
			killMe
		}
	}
	
	on solution{
		emit(new solution(occurrence.route))[it.ID == taskAgentUUID]
	}

	on customerInserted {
		info("Customer inserted.")
		
		for(vehicle_agent: getMemberAgents()){
			this.vehicle_agents.add(vehicle_agent)
		}

		var vehicle_customer_relocate : UUID = this.vehicle_agents.poll()
		innerContext.defaultSpace.emit(this.ID, new removeAll())[it.ID == vehicle_customer_relocate]

	}
	
	on relocate {
		info("Relocating all customers.")
		
		if (occurrence.customers.isEmpty) {
			info("Empty vehicle.")

			if (!this.vehicle_agents.isEmpty()) {
				var vehicle_customer_relocate : UUID = this.vehicle_agents.poll()
				innerContext.defaultSpace.emit(this.ID, new removeAll())[it.ID == vehicle_customer_relocate]
			} else {
				// Emit a new customer request
				emit(new nextCustomerRequest())[it.ID == taskAgentUUID]
			}

		} else {

			// Add all the customers to relocate
			for (customer : occurrence.customers) {
				this.customer_relocate.add(customer)
			}

			actual_customer_insert = this.customer_relocate.poll()
			// Emit the event in the default space of inner context
			innerContext.defaultSpace.emit(this.ID, new relocateCustomerEstimate(actual_customer_insert))
			
		}
	}

	on customerRelocated {
		if (!this.vehicle_agents.isEmpty()) {
			var vehicle_customer_relocate : UUID = this.vehicle_agents.poll()
			innerContext.defaultSpace.emit(this.ID, new removeAll())[it.ID == vehicle_customer_relocate]
		} else {
			// Emit a new customer request
			emit(new nextCustomerRequest())[it.ID == taskAgentUUID]
		}
	}

	on relocateCostEstimation {
		info("Estimation received.")

		synchronized (this) {
			// Increment the number of response of vehicle agent
			this.number_agent_returned++

			// If the solution is the best found
			if (best_insertion_cost > occurrence.cost) {
				// Save the cost
				best_insertion_cost = occurrence.cost
				// Save the vehicle agent that have the best insertion proposal
				best_vehicle_insert = occurrence.source.ID
			}
			
			if (this.number_agent_returned == this.number_vehicle) {

				// Reset the insertion values
				best_insertion_cost = Integer.MAX_VALUE
				number_agent_returned = 0

				info("Request to relocate customer.")

				innerContext.defaultSpace.emit(this.ID, new relocateCustomer(actual_customer_insert)) [
					it.ID == best_vehicle_insert
				]
			} 
		}
	}

	on Destroy {
		var dieEvt = new die()
		emit(dieEvt)[it.ID == taskAgentUUID]
	}
	
	on insertionCostEstimation {
		info("Estimation received.")
	
		synchronized (this) {
			// Increment the number of response of vehicle agent
			this.number_agent_returned++
			
			// If the solution is the best found
			if (best_insertion_cost > occurrence.cost) {
				// Save the cost
				best_insertion_cost = occurrence.cost
				// Save the vehicle agent that have the best insertion proposal
				best_vehicle_insert = occurrence.source.ID
			}
			if (this.number_agent_returned == this.number_vehicle && best_insertion_cost < Integer.MAX_VALUE) {
				
				// Reset the insertion values
				best_insertion_cost = Integer.MAX_VALUE
				number_agent_returned = 0

				info("Request to insert customer.")

				// Insert the customer
				var insertCustomerEvt = new insertCustomer(actual_customer_insert)
				innerContext.defaultSpace.emit(this.ID, insertCustomerEvt)[it.ID == best_vehicle_insert]

			} else if (this.number_agent_returned == this.number_vehicle) {
				info("Spawning a new vehicle agent.")

				// Reset the insertion values
				best_insertion_cost = Integer.MAX_VALUE
				number_agent_returned = 0
				
				var vehicleUUID : UUID = UUID.randomUUID()
				// Spawn the VehicleAgent
				spawnInContextWithID(typeof(VehicleAgent), vehicleUUID, innerContext, depot, vehicle_capacity, this.ID)
				// increment the number of vehicle
				number_vehicle.incrementAndGet()

				// Wait the vehicle agents to spawn
				val task = task("waiting_for_vehicle_agent_" + number_vehicle.get().toString())
				task.every(100) [
					if (getMemberAgentCount() == number_vehicle.get()) {
						info("Restarting CNP.")

						// Retry to insert the customer
						innerContext.defaultSpace.emit(this.ID, new insertCustomerEstimate(actual_customer_insert))
						task.cancel
					}
				]
			
			}
		}
	}

}

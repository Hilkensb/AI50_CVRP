/** 
 * 
 */
package fr.utbm.cvrp.solver

import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.ParticipantJoined
import io.sarl.core.ParticipantLeft
import io.sarl.core.SpaceCreated
import io.sarl.core.SpaceDestroyed
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Lifecycle
import io.sarl.core.InnerContextAccess
import io.sarl.core.Schedules
import java.util.UUID
import java.util.ArrayList

/** 
 * @author neil
 * 
 */
agent TaskAgent {
	uses Logging, DefaultContextInteractions, Lifecycle, InnerContextAccess, Schedules

	// UUID of the allocationAgent
	var allocationAgentUUID : UUID

	// id, x, y of the depot node
	var depot : String
	// List of customers to allocate
	var customers : ConcurrentLinkedQueue<String> = new ConcurrentLinkedQueue<String>
	// Vehicle capacity
	var vehicle_capacity : AtomicInteger = new AtomicInteger()

	// bool value to know if the allocation agent has spawned
	var allocation_agent_spawned : boolean = false
	
	// Solution found
	var solution_found : ConcurrentLinkedQueue<ArrayList<String>> = new ConcurrentLinkedQueue<ArrayList<String>>

	on Initialize {
		// Set the logging name of the agent
		loggingName = "Task Agent"
		// Tell on logging that the agent started normally
		info("The agent has started.")

		// Get the customers, depot and capacity
		depot = occurrence.parameters.get(0) as String
		customers = occurrence.parameters.get(1) as ConcurrentLinkedQueue<String>
		vehicle_capacity = occurrence.parameters.get(2) as AtomicInteger
		// We do not order the list since we will implement the FIFO strategy since
		// it has nearly the same result as the MDF strategy. By doing that
		// we avoid a costly ordering operation
		
		// Determine the lowerbound number of vehicles
		var lower_bound_vehicle : int = this.getLowerBoundVehiculeNumber(customers)
		// Spawn the Allocation agent
		// First create an uuid
		allocationAgentUUID = UUID.randomUUID()
		
		// Then spawn the allocation agent in the inner context
		spawnInContextWithID(typeof(AllocationAgent), allocationAgentUUID, innerContext, depot, vehicle_capacity, lower_bound_vehicle, this.ID)
	}

	on nextCustomerRequest {
		// Use the ITER strategy since the strategy has showed better results
		// than the BATCH strategy. The ITER (for iterative) strategy consists
		// in sending customers one by one to the allocation agent
		info("Next customer requested.")

		// Wait for the allocation agent to spawn
		val task = task("waiting_for_allocation_agent" + customers.length.toString())
		task.every(100) [
			if (allocation_agent_spawned) {
				if (!customers.isEmpty()) {
					// Create the next customer event containing th enext customer to allocate
					var nextCustomerEvt = new nextCustomer(this.getNextCustomers())
					// Emit the event in the inner context to the allocationAgentUUID
					innerContext.defaultSpace.emit(this.ID, nextCustomerEvt)[it.ID == allocationAgentUUID]
				} else {
					info("No more customer.")
					var finishEvt = new finish()
					// Emit the event in the inner context to the allocationAgentUUID
					innerContext.defaultSpace.emit(this.ID, finishEvt)[it.ID == allocationAgentUUID]
				}
				task.cancel
			}
		]
	}

	on ParticipantJoined [occurrence.spaceID == innerContext.defaultSpace.spaceID] {
		// The allocation has spawned
		allocation_agent_spawned = true
	}

	on die {
		info("Killing myself.")
		killMe
	}
	
	on solution {
		solution_found.add(occurrence.route)
	}

	/*************************** TaskAgent methods behavior **************************
	 */
	
	def getNextCustomers() : String {
		// Pop the last element
		return customers.poll()
	}

	def getId(customer_string : String) : int {
		// Get the demand as string first
		var customer_id_string : String = customer_string.split(" ").get(0)
		// Convert it to int
		var customer_id : int = Integer.parseInt(customer_id_string)

		return customer_id
	}

	def getX(customer_string : String) : int {
		// Get the demand as string first
		var customer_x_string : String = customer_string.split(" ").get(1)
		// Convert it to int
		var customer_x : int = Integer.parseInt(customer_x_string)

		return customer_x
	}

	def getY(customer_string : String) : int {
		// Get the demand as string first
		var customer_y_string : String = customer_string.split(" ").get(2)
		// Convert it to int
		var customer_y : int = Integer.parseInt(customer_y_string)

		return customer_y
	}

	def getDemand(customer_string : String) : int {
		// Get the demand as string first
		var customer_demand_string : String = customer_string.split(" ").get(3)
		// Convert it to int
		var customer_demand : int = Integer.parseInt(customer_demand_string)

		return customer_demand
	}

	def getLowerBoundVehiculeNumber(customersList : ConcurrentLinkedQueue<String>) : int {

		var sum_demand : int = 0
		// For every customer we will sum the demand of all customers
		for (customer : customersList) {
			// Sum the demand
			sum_demand += this.getDemand(customer)
		}

		// Get the lower bound number of vehicle
		var number_vehicle : int = Math.ceil(sum_demand / this.vehicle_capacity.intValue()).intValue()

		return number_vehicle
	}
}

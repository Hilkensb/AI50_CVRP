/** 
 * 
 */
package fr.utbm.cvrp.solver


import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.ParticipantJoined
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger
import io.sarl.core.Lifecycle
import io.sarl.core.InnerContextAccess
import io.sarl.core.Schedules
import java.util.UUID
import java.util.ArrayList

/** 
 * Task Agent
 * <br>His goal is to give the customers to the allocation agent
 * <br>Strategies implemented: FIFO-ITER
 * 
 */
agent TaskAgent {
	// Skills used
	uses Logging, Lifecycle, InnerContextAccess, Schedules

	// UUID of the allocationAgent
	var allocationAgentUUID : UUID

	// id, x, y of the depot node
	var depot : String
	// List of customers to allocate
	var customers : ConcurrentLinkedQueue<String> = new ConcurrentLinkedQueue<String>
	// Vehicle capacity
	var vehicle_capacity : AtomicInteger = new AtomicInteger()

	// boolean value to know if the allocation agent has spawned
	var allocation_agent_spawned : boolean = false
	
	// Solution found
	var solution_found : ConcurrentLinkedQueue<ArrayList<String>> = new ConcurrentLinkedQueue<ArrayList<String>>

	on Initialize {
		// Set the logging name of the agent
		loggingName = "Task Agent"
		// Tell on logging that the agent started normally
		info("The agent has started.")

		// Get the customers, depot and capacity
		this.depot = occurrence.parameters.get(0) as String
		this.customers = occurrence.parameters.get(1) as ConcurrentLinkedQueue<String>
		this.vehicle_capacity = occurrence.parameters.get(2) as AtomicInteger
		// We do not order the list since we will implement the FIFO strategy since
		// it has nearly the same result as the MDF strategy. By doing that
		// we avoid a costly ordering operation
		
		// Determine the lower bound number of vehicles
		var lower_bound_vehicle : int = this.getLowerBoundVehiculeNumber(this.customers)
		// Spawn the Allocation agent
		// First create an uuid
		this.allocationAgentUUID = UUID.randomUUID()
		
		// Then spawn the allocation agent in the inner context
		spawnInContextWithID(typeof(AllocationAgent), allocationAgentUUID, innerContext, depot, vehicle_capacity, lower_bound_vehicle, this.ID)
	}

	on nextCustomerRequest {
		// Use the ITER strategy since the strategy has showed better results
		// than the BATCH strategy. The ITER (for iterative) strategy consists
		// in sending customers one by one to the allocation agent
		info("Next customer requested.")

		// Wait for the allocation agent to spawn
		val task = task("waiting_for_allocation_agent" + customers.length.toString())
		task.every(100) [
			// If the allocation agent has already spawned
			if (allocation_agent_spawned) {
				if (!customers.isEmpty()) {
					// Logging info
					info("Sending the next customer.")
					
					// Create the next customer event containing th enext customer to allocate
					var nextCustomerEvt = new nextCustomer(this.getNextCustomers())
					// Emit the event in the inner context to the allocationAgentUUID
					innerContext.defaultSpace.emit(this.ID, nextCustomerEvt)[it.ID == allocationAgentUUID]
				} else {
					// Logging info
					info("No more customer.")
					
					var finishEvt = new finish()
					// Emit the event in the inner context to the allocationAgentUUID
					innerContext.defaultSpace.emit(this.ID, finishEvt)[it.ID == allocationAgentUUID]
				}
				task.cancel
			}
		]
	}

	on ParticipantJoined [occurrence.spaceID == innerContext.defaultSpace.spaceID] {
		// The allocation has spawned
		// No need of synchronization since boolean are made of atomic value (1 bit value)
		// So it's thread safe
		this.allocation_agent_spawned = true
	}

	on die {
		// The vehicles agents and the allocation agents has been killed
		// The agent can kill itself 
		// Logging info
		info("Killing myself.")
		// Kill itself
		killMe
	}
	
	on solution {
		// Add the route gived by the allocation agent to the solution
		solution_found.add(occurrence.route)
	}

	/*************************** TaskAgent methods behavior **************************
	 */
	
	def getNextCustomers() : String {
		/**
		 * Method to get the next customer
		 */
		 
		// Pop the last element
		// Thread safe linked queue
		// No need of synchronization
		return customers.poll()
	}

	def getId(customer_string : String) : int {
		/**
		 * Method to get the id from a string that represent a customer
		 * 
		 * @param customer_string: String that represent the customer
		 * @return The id of the given customer
		 * 
		 ***/
		 
		// Get the demand as string first
		var customer_id_string : String = customer_string.split(" ").get(0)
		// Convert it to int
		var customer_id : int = Integer.parseInt(customer_id_string)

		return customer_id
	}

	def getX(customer_string : String) : int {
		/**
		 * Method to get the X coordinate of the given customer
		 * 
		 * @param customer_string: String that represent the customer
		 * @return The X coordinates of the given customer
		 * 
		 */ 

		// Get the demand as string first
		var customer_x_string : String = customer_string.split(" ").get(1)
		// Convert it to int
		var customer_x : int = Integer.parseInt(customer_x_string)

		return customer_x
	}

	def getY(customer_string : String) : int {
		/**
		 * Method to get the Y coordinate of the given customer
		 * 
		 * @param customer_string: String that represent the customer
		 * @return The Y coordinates of the given customer
		 * 
		 */ 
		
		// Get the demand as string first
		var customer_y_string : String = customer_string.split(" ").get(2)
		// Convert it to int
		var customer_y : int = Integer.parseInt(customer_y_string)

		return customer_y
	}

	def getDemand(customer_string : String) : int {
		/**
		 * Method to get the demand of the given customer
		 * 
		 * @param customer_string: String that represent the customer
		 * @return The demand coordinates of the given customer
		 * 
		 */ 
		
		// Get the demand as string first
		var customer_demand_string : String = customer_string.split(" ").get(3)
		// Convert it to int
		var customer_demand : int = Integer.parseInt(customer_demand_string)

		return customer_demand
	}

	def getLowerBoundVehiculeNumber(customersList : ConcurrentLinkedQueue<String>) : int {
		/*
		 * Method to determine the lower bound number of vehicle
		 * 
		 * @param customersList List of all customers in the cvrp instance
		 * @return the lower bound number of vehicle to get a solution of this instance
		 * 
		 */

		var sum_demand : int = 0
		// For every customer we will sum the demand of all customers
		for (customer : customersList) {
			// Sum the demand
			sum_demand += this.getDemand(customer)
		}

		// Get the lower bound number of vehicle
		var number_vehicle : int = Math.ceil(sum_demand / this.vehicle_capacity.intValue()).intValue()

		return number_vehicle
	}
}
